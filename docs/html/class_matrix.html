<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.5"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>CrustEngine: Matrix&lt; T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">CrustEngine<span id="projectnumber">&#160;0.0.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.5 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('class_matrix.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#pro-static-attribs">Static Protected Attributes</a> &#124;
<a href="class_matrix-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">Matrix&lt; T &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Represents the mathematical matrix and is able to preform matrix calculations.  
 <a href="class_matrix.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_matrix_8hpp_source.html">Matrix.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ac3e974170cd6bb780272211ae66c598e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_matrix.html#ac3e974170cd6bb780272211ae66c598e">Matrix</a> ()</td></tr>
<tr class="memdesc:ac3e974170cd6bb780272211ae66c598e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This constructor does not reserves the memory for the matrix's array. It only creates memory space for matrix pointer. This means that pointer will be accesiable but no value can be put inside of if. The matrix will be of size 0x0.  <a href="class_matrix.html#ac3e974170cd6bb780272211ae66c598e">More...</a><br /></td></tr>
<tr class="separator:ac3e974170cd6bb780272211ae66c598e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88b06f13012ade46bce4bae86c7980f4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_matrix.html#a88b06f13012ade46bce4bae86c7980f4">Matrix</a> (uint32_t <a class="el" href="class_matrix.html#a5ccb58af982a27187232cc8c07a94da8">height</a>, uint32_t <a class="el" href="class_matrix.html#ad43ea7e5e99130cffdb7b93ce25f4436">width</a>)</td></tr>
<tr class="memdesc:a88b06f13012ade46bce4bae86c7980f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">If any argument is zero then no space for matrix's array will be allocated.  <a href="class_matrix.html#a88b06f13012ade46bce4bae86c7980f4">More...</a><br /></td></tr>
<tr class="separator:a88b06f13012ade46bce4bae86c7980f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d7743924a9d9182c675372f0b16c13d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_matrix.html#a9d7743924a9d9182c675372f0b16c13d">Matrix</a> (uint32_t <a class="el" href="class_matrix.html#a5ccb58af982a27187232cc8c07a94da8">height</a>, uint32_t <a class="el" href="class_matrix.html#ad43ea7e5e99130cffdb7b93ce25f4436">width</a>, T defaultVal)</td></tr>
<tr class="memdesc:a9d7743924a9d9182c675372f0b16c13d"><td class="mdescLeft">&#160;</td><td class="mdescRight">If width or height argument is zero then no space for matrix's array will be allocated.  <a href="class_matrix.html#a9d7743924a9d9182c675372f0b16c13d">More...</a><br /></td></tr>
<tr class="separator:a9d7743924a9d9182c675372f0b16c13d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c8b229ce6eeca4740015a8655b04e8a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_matrix.html#a5c8b229ce6eeca4740015a8655b04e8a">Matrix</a> (<a class="el" href="class_matrix.html">Matrix</a>&lt; T &gt; &amp;other)</td></tr>
<tr class="separator:a5c8b229ce6eeca4740015a8655b04e8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a280b1a450f7d492a428ea843b3734a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_matrix.html#a1a280b1a450f7d492a428ea843b3734a">~Matrix</a> ()</td></tr>
<tr class="separator:a1a280b1a450f7d492a428ea843b3734a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86d796adbcc1ac8564e9e2306360f590"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_matrix.html#a86d796adbcc1ac8564e9e2306360f590">Height</a> () const</td></tr>
<tr class="memdesc:a86d796adbcc1ac8564e9e2306360f590"><td class="mdescLeft">&#160;</td><td class="mdescRight">Getter for <a class="el" href="class_matrix.html#a86d796adbcc1ac8564e9e2306360f590" title="Getter for Height field.">Height</a> field.  <a href="class_matrix.html#a86d796adbcc1ac8564e9e2306360f590">More...</a><br /></td></tr>
<tr class="separator:a86d796adbcc1ac8564e9e2306360f590"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a70fa7bc4ca43742b4552189aa62296"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_matrix.html#a5a70fa7bc4ca43742b4552189aa62296">Width</a> () const</td></tr>
<tr class="memdesc:a5a70fa7bc4ca43742b4552189aa62296"><td class="mdescLeft">&#160;</td><td class="mdescRight">Getter for <a class="el" href="class_matrix.html#a5a70fa7bc4ca43742b4552189aa62296" title="Getter for Width field.">Width</a> field.  <a href="class_matrix.html#a5a70fa7bc4ca43742b4552189aa62296">More...</a><br /></td></tr>
<tr class="separator:a5a70fa7bc4ca43742b4552189aa62296"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2555ef99ac404304432e38a38bf46f5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_matrix.html">Matrix</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_matrix.html#aa2555ef99ac404304432e38a38bf46f5">operator+=</a> (const <a class="el" href="class_matrix.html">Matrix</a>&lt; T &gt; &amp;other) noexcept</td></tr>
<tr class="memdesc:aa2555ef99ac404304432e38a38bf46f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds #other matrix to this one. Each value at according x and y position will be added to each other. If sizes of matrixes do not match no changes will be done.  <a href="class_matrix.html#aa2555ef99ac404304432e38a38bf46f5">More...</a><br /></td></tr>
<tr class="separator:aa2555ef99ac404304432e38a38bf46f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac266a5c1c70819a79993bcf1976c460d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_matrix.html">Matrix</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_matrix.html#ac266a5c1c70819a79993bcf1976c460d">operator+=</a> (std::initializer_list&lt; T &gt; l) noexcept</td></tr>
<tr class="memdesc:ac266a5c1c70819a79993bcf1976c460d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds #l list to this matrix. If sizes of matrixes do not match no changes will be done.  <a href="class_matrix.html#ac266a5c1c70819a79993bcf1976c460d">More...</a><br /></td></tr>
<tr class="separator:ac266a5c1c70819a79993bcf1976c460d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66eeebd9fde92d999fa939f43ce250a7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_matrix.html">Matrix</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_matrix.html#a66eeebd9fde92d999fa939f43ce250a7">operator+=</a> (const T value) noexcept</td></tr>
<tr class="memdesc:a66eeebd9fde92d999fa939f43ce250a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds #value to each value in this matrix.  <a href="class_matrix.html#a66eeebd9fde92d999fa939f43ce250a7">More...</a><br /></td></tr>
<tr class="separator:a66eeebd9fde92d999fa939f43ce250a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9eee11ca0c6f792e126688c0933fb850"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_matrix.html">Matrix</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_matrix.html#a9eee11ca0c6f792e126688c0933fb850">operator-=</a> (const <a class="el" href="class_matrix.html">Matrix</a>&lt; T &gt; &amp;other) noexcept</td></tr>
<tr class="memdesc:a9eee11ca0c6f792e126688c0933fb850"><td class="mdescLeft">&#160;</td><td class="mdescRight">Substracts #other matrix to this one. Each value at according x and y position will be substracted to each other. If sizes of matrixes do not match no changes will be done.  <a href="class_matrix.html#a9eee11ca0c6f792e126688c0933fb850">More...</a><br /></td></tr>
<tr class="separator:a9eee11ca0c6f792e126688c0933fb850"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a580932af62fe857f9e4aa915e18adaab"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_matrix.html">Matrix</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_matrix.html#a580932af62fe857f9e4aa915e18adaab">operator-=</a> (std::initializer_list&lt; T &gt; l) noexcept</td></tr>
<tr class="memdesc:a580932af62fe857f9e4aa915e18adaab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Substracts #l list to this matrix. If sizes of matrixes do not match no changes will be done.  <a href="class_matrix.html#a580932af62fe857f9e4aa915e18adaab">More...</a><br /></td></tr>
<tr class="separator:a580932af62fe857f9e4aa915e18adaab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78c0d57c3e37e3bcba6ed3ec218cefda"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_matrix.html">Matrix</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_matrix.html#a78c0d57c3e37e3bcba6ed3ec218cefda">operator-=</a> (const T value) noexcept</td></tr>
<tr class="memdesc:a78c0d57c3e37e3bcba6ed3ec218cefda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Substracts #value to each value in this matrix.  <a href="class_matrix.html#a78c0d57c3e37e3bcba6ed3ec218cefda">More...</a><br /></td></tr>
<tr class="separator:a78c0d57c3e37e3bcba6ed3ec218cefda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19e69104038c26d50bf456e231faf842"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_matrix.html">Matrix</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_matrix.html#a19e69104038c26d50bf456e231faf842">operator*=</a> (const <a class="el" href="class_matrix.html">Matrix</a>&lt; T &gt; &amp;other) noexcept</td></tr>
<tr class="memdesc:a19e69104038c26d50bf456e231faf842"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies this matrix by #other. If sizes of matrixes do not match no changes will be done.  <a href="class_matrix.html#a19e69104038c26d50bf456e231faf842">More...</a><br /></td></tr>
<tr class="separator:a19e69104038c26d50bf456e231faf842"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5a0f163631af1d3efffc23a9acb1ef8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_matrix.html">Matrix</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_matrix.html#ab5a0f163631af1d3efffc23a9acb1ef8">operator*=</a> (std::initializer_list&lt; T &gt; l) noexcept</td></tr>
<tr class="memdesc:ab5a0f163631af1d3efffc23a9acb1ef8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies this matrix by matrix made from #l initializer list.  <a href="class_matrix.html#ab5a0f163631af1d3efffc23a9acb1ef8">More...</a><br /></td></tr>
<tr class="separator:ab5a0f163631af1d3efffc23a9acb1ef8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a494aa8b0270528cbb48624037dd198da"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_matrix.html">Matrix</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_matrix.html#a494aa8b0270528cbb48624037dd198da">operator*=</a> (const T value) noexcept</td></tr>
<tr class="memdesc:a494aa8b0270528cbb48624037dd198da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies each value of this matrix by #value.  <a href="class_matrix.html#a494aa8b0270528cbb48624037dd198da">More...</a><br /></td></tr>
<tr class="separator:a494aa8b0270528cbb48624037dd198da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85b13ebfb06ef4b9b1e5c832e2f1e6bb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_matrix.html">Matrix</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_matrix.html#a85b13ebfb06ef4b9b1e5c832e2f1e6bb">operator/=</a> (const <a class="el" href="class_matrix.html">Matrix</a>&lt; T &gt; &amp;other) noexcept</td></tr>
<tr class="memdesc:a85b13ebfb06ef4b9b1e5c832e2f1e6bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Divides this matrix by #other matrix. Each value at according x and y position will be divided to each other. If sizes of matrixes do not match no changes will be done.  <a href="class_matrix.html#a85b13ebfb06ef4b9b1e5c832e2f1e6bb">More...</a><br /></td></tr>
<tr class="separator:a85b13ebfb06ef4b9b1e5c832e2f1e6bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e420a0361b60c45f32124526194670c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_matrix.html">Matrix</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_matrix.html#a0e420a0361b60c45f32124526194670c">operator/=</a> (const T value) noexcept</td></tr>
<tr class="memdesc:a0e420a0361b60c45f32124526194670c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Divides each value of this matrix by #value.  <a href="class_matrix.html#a0e420a0361b60c45f32124526194670c">More...</a><br /></td></tr>
<tr class="separator:a0e420a0361b60c45f32124526194670c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a998d8e9696ae022cf0aaaa30281fad12"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_matrix.html">Matrix</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_matrix.html#a998d8e9696ae022cf0aaaa30281fad12">operator=</a> (const <a class="el" href="class_matrix.html">Matrix</a>&lt; T &gt; &amp;other) noexcept</td></tr>
<tr class="memdesc:a998d8e9696ae022cf0aaaa30281fad12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mimic #other matrix. Takes it's height, width and values and copies it to self.  <a href="class_matrix.html#a998d8e9696ae022cf0aaaa30281fad12">More...</a><br /></td></tr>
<tr class="separator:a998d8e9696ae022cf0aaaa30281fad12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6325e23bef0bc407a92ddbccf1991ab8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_matrix.html">Matrix</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_matrix.html#a6325e23bef0bc407a92ddbccf1991ab8">operator=</a> (std::initializer_list&lt; T &gt; l) noexcept</td></tr>
<tr class="memdesc:a6325e23bef0bc407a92ddbccf1991ab8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mimic values stored in #l initializer list.  <a href="class_matrix.html#a6325e23bef0bc407a92ddbccf1991ab8">More...</a><br /></td></tr>
<tr class="separator:a6325e23bef0bc407a92ddbccf1991ab8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad63e44d010ca1f300f6cc26cceb827a2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_matrix.html#ad63e44d010ca1f300f6cc26cceb827a2">operator==</a> (const <a class="el" href="class_matrix.html">Matrix</a>&lt; T &gt; &amp;other) noexcept</td></tr>
<tr class="memdesc:ad63e44d010ca1f300f6cc26cceb827a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method comparing two matrixes. It firstly checks the sizes. Then the types and at last values at each position.  <a href="class_matrix.html#ad63e44d010ca1f300f6cc26cceb827a2">More...</a><br /></td></tr>
<tr class="separator:ad63e44d010ca1f300f6cc26cceb827a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1df14d18d1431142741a24448c419cc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_matrix.html#af1df14d18d1431142741a24448c419cc">operator!=</a> (const <a class="el" href="class_matrix.html">Matrix</a>&lt; T &gt; &amp;other) noexcept</td></tr>
<tr class="memdesc:af1df14d18d1431142741a24448c419cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method comparing two matrixes. It firstly checks the sizes. Then the types and at last values at each position.  <a href="class_matrix.html#af1df14d18d1431142741a24448c419cc">More...</a><br /></td></tr>
<tr class="separator:af1df14d18d1431142741a24448c419cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18b7992498c06bea4e240bd7f504ee90"><td class="memItemLeft" align="right" valign="top">T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_matrix.html#a18b7992498c06bea4e240bd7f504ee90">operator[]</a> (int x) const noexcept</td></tr>
<tr class="memdesc:a18b7992498c06bea4e240bd7f504ee90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Getter for values in this matrix. It allows us to perform 2D array-style value getting or getter for pointer to each column.  <a href="class_matrix.html#a18b7992498c06bea4e240bd7f504ee90">More...</a><br /></td></tr>
<tr class="separator:a18b7992498c06bea4e240bd7f504ee90"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-attribs" name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a5ccb58af982a27187232cc8c07a94da8"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_matrix.html#a5ccb58af982a27187232cc8c07a94da8">height</a> {0}</td></tr>
<tr class="memdesc:a5ccb58af982a27187232cc8c07a94da8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Amount of Height in the matrix.  <a href="class_matrix.html#a5ccb58af982a27187232cc8c07a94da8">More...</a><br /></td></tr>
<tr class="separator:a5ccb58af982a27187232cc8c07a94da8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad43ea7e5e99130cffdb7b93ce25f4436"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_matrix.html#ad43ea7e5e99130cffdb7b93ce25f4436">width</a> {0}</td></tr>
<tr class="memdesc:ad43ea7e5e99130cffdb7b93ce25f4436"><td class="mdescLeft">&#160;</td><td class="mdescRight">Amount of Width in the matrix.  <a href="class_matrix.html#ad43ea7e5e99130cffdb7b93ce25f4436">More...</a><br /></td></tr>
<tr class="separator:ad43ea7e5e99130cffdb7b93ce25f4436"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34d60cf534436a6c0985c61eec302be2"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_matrix.html#a34d60cf534436a6c0985c61eec302be2">totalSize</a> {0}</td></tr>
<tr class="memdesc:a34d60cf534436a6c0985c61eec302be2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Total size is a multiplied values of a height and a width. It is a count f elements in an array of <a class="el" href="class_matrix.html#a68c40458ceb26414fd703acd3f98f2be" title="Array of matrix&#39;s values. It is linear despite matrix being 2-dimensional. It is more efficiently.">mat</a>.  <a href="class_matrix.html#a34d60cf534436a6c0985c61eec302be2">More...</a><br /></td></tr>
<tr class="separator:a34d60cf534436a6c0985c61eec302be2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68c40458ceb26414fd703acd3f98f2be"><td class="memItemLeft" align="right" valign="top">T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_matrix.html#a68c40458ceb26414fd703acd3f98f2be">mat</a> {nullptr}</td></tr>
<tr class="memdesc:a68c40458ceb26414fd703acd3f98f2be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Array of matrix's values. It is linear despite matrix being 2-dimensional. It is more efficiently.  <a href="class_matrix.html#a68c40458ceb26414fd703acd3f98f2be">More...</a><br /></td></tr>
<tr class="separator:a68c40458ceb26414fd703acd3f98f2be"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-static-attribs" name="pro-static-attribs"></a>
Static Protected Attributes</h2></td></tr>
<tr class="memitem:ac274897b49c87ddcca3398fce2555fb3"><td class="memItemLeft" align="right" valign="top">static T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_matrix.html#ac274897b49c87ddcca3398fce2555fb3">tmpMat</a> {nullptr}</td></tr>
<tr class="memdesc:ac274897b49c87ddcca3398fce2555fb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">second matrix allocated only once. This matrix is used for calculation purposes. It allows us to safely multiply matrixes without a need to allocate more memory.  <a href="class_matrix.html#ac274897b49c87ddcca3398fce2555fb3">More...</a><br /></td></tr>
<tr class="separator:ac274897b49c87ddcca3398fce2555fb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b1de83dfa8d942e6ad25b4899f258de"><td class="memItemLeft" align="right" valign="top">static constexpr uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_matrix.html#a0b1de83dfa8d942e6ad25b4899f258de">MAX_MATRIX_SIZE</a> {4096}</td></tr>
<tr class="memdesc:a0b1de83dfa8d942e6ad25b4899f258de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum size of a matrix that calculation will be performed on. This is a theoreticall value and if some calculation will be done on bigger matrix bad things happens.  <a href="class_matrix.html#a0b1de83dfa8d942e6ad25b4899f258de">More...</a><br /></td></tr>
<tr class="separator:a0b1de83dfa8d942e6ad25b4899f258de"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;class T&gt;<br />
class Matrix&lt; T &gt;</div><p >Represents the mathematical matrix and is able to preform matrix calculations. </p>
<p >This matrix class assumes that x value is the number of a column and y value is the number of a row. This means that matrix[3][2] is value in 3rd row and 2nd column. Also height says how many rows there are and width says how many columns there are.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Types of values held in this matrix. </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ac3e974170cd6bb780272211ae66c598e" name="ac3e974170cd6bb780272211ae66c598e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3e974170cd6bb780272211ae66c598e">&#9670;&#160;</a></span>Matrix() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class E &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_matrix.html">Matrix</a>&lt; E &gt;<a class="el" href="class_matrix.html">::Matrix</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This constructor does not reserves the memory for the matrix's array. It only creates memory space for matrix pointer. This means that pointer will be accesiable but no value can be put inside of if. The matrix will be of size 0x0. </p>

</div>
</div>
<a id="a88b06f13012ade46bce4bae86c7980f4" name="a88b06f13012ade46bce4bae86c7980f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88b06f13012ade46bce4bae86c7980f4">&#9670;&#160;</a></span>Matrix() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class E &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_matrix.html">Matrix</a>&lt; E &gt;<a class="el" href="class_matrix.html">::Matrix</a> </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>width</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If any argument is zero then no space for matrix's array will be allocated. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Height</td><td>Amount of Height in the matrix. </td></tr>
    <tr><td class="paramname">Width</td><td>Amount of Width in the matrix. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9d7743924a9d9182c675372f0b16c13d" name="a9d7743924a9d9182c675372f0b16c13d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d7743924a9d9182c675372f0b16c13d">&#9670;&#160;</a></span>Matrix() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_matrix.html">Matrix</a>&lt; T &gt;<a class="el" href="class_matrix.html">::Matrix</a> </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>defaultVal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If width or height argument is zero then no space for matrix's array will be allocated. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Height</td><td>Amount of Height in the matrix. </td></tr>
    <tr><td class="paramname">Width</td><td>Amount of Width in the matrix. </td></tr>
    <tr><td class="paramname">defaultVal</td><td>The value that will be placed on each position in matrix. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5c8b229ce6eeca4740015a8655b04e8a" name="a5c8b229ce6eeca4740015a8655b04e8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c8b229ce6eeca4740015a8655b04e8a">&#9670;&#160;</a></span>Matrix() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_matrix.html">Matrix</a>&lt; T &gt;<a class="el" href="class_matrix.html">::Matrix</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_matrix.html">Matrix</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1a280b1a450f7d492a428ea843b3734a" name="a1a280b1a450f7d492a428ea843b3734a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a280b1a450f7d492a428ea843b3734a">&#9670;&#160;</a></span>~Matrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class E &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_matrix.html">Matrix</a>&lt; E &gt;::~<a class="el" href="class_matrix.html">Matrix</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >If <a class="el" href="class_matrix.html#a68c40458ceb26414fd703acd3f98f2be" title="Array of matrix&#39;s values. It is linear despite matrix being 2-dimensional. It is more efficiently.">mat</a> is not null deletes it from the heap. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a86d796adbcc1ac8564e9e2306360f590" name="a86d796adbcc1ac8564e9e2306360f590"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86d796adbcc1ac8564e9e2306360f590">&#9670;&#160;</a></span>Height()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class E &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t <a class="el" href="class_matrix.html">Matrix</a>&lt; E &gt;::Height</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Getter for <a class="el" href="class_matrix.html#a86d796adbcc1ac8564e9e2306360f590" title="Getter for Height field.">Height</a> field. </p>
<dl class="section return"><dt>Returns</dt><dd>Amount of Height in matrix. </dd></dl>

</div>
</div>
<a id="af1df14d18d1431142741a24448c419cc" name="af1df14d18d1431142741a24448c419cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1df14d18d1431142741a24448c419cc">&#9670;&#160;</a></span>operator!=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_matrix.html">Matrix</a>&lt; E &gt;::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_matrix.html">Matrix</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Method comparing two matrixes. It firstly checks the sizes. Then the types and at last values at each position. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>Value to which this one is compared. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true If something is not the same in these matrixes. </dd>
<dd>
false If everything is eaxctly the same in these matrixes. </dd></dl>

</div>
</div>
<a id="a19e69104038c26d50bf456e231faf842" name="a19e69104038c26d50bf456e231faf842"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19e69104038c26d50bf456e231faf842">&#9670;&#160;</a></span>operator*=() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_matrix.html">Matrix</a>&lt; T &gt; &amp; <a class="el" href="class_matrix.html">Matrix</a>&lt; T &gt;::operator*= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_matrix.html">Matrix</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplies this matrix by #other. If sizes of matrixes do not match no changes will be done. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td><a class="el" href="class_matrix.html" title="Represents the mathematical matrix and is able to preform matrix calculations.">Matrix</a> by which this one will be multiplied. #other matrix will remain unchanged. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Matrix&lt;T&gt;&amp; Reference to *this matrix multiplied by #other. </dd></dl>

</div>
</div>
<a id="a494aa8b0270528cbb48624037dd198da" name="a494aa8b0270528cbb48624037dd198da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a494aa8b0270528cbb48624037dd198da">&#9670;&#160;</a></span>operator*=() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_matrix.html">Matrix</a>&lt; T &gt; &amp; <a class="el" href="class_matrix.html">Matrix</a>&lt; T &gt;::operator*= </td>
          <td>(</td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplies each value of this matrix by #value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>Value by which value at each position of this matrix will be multiplied. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Matrix&lt;T&gt;&amp; Reference to *this matrix with values multiplied. </dd></dl>

</div>
</div>
<a id="ab5a0f163631af1d3efffc23a9acb1ef8" name="ab5a0f163631af1d3efffc23a9acb1ef8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5a0f163631af1d3efffc23a9acb1ef8">&#9670;&#160;</a></span>operator*=() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_matrix.html">Matrix</a>&lt; T &gt; &amp; <a class="el" href="class_matrix.html">Matrix</a>&lt; T &gt;::operator*= </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; T &gt;&#160;</td>
          <td class="paramname"><em>l</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplies this matrix by matrix made from #l initializer list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">l</td><td>initializer list that fits the convention of <a class="el" href="class_matrix.html#a68c40458ceb26414fd703acd3f98f2be" title="Array of matrix&#39;s values. It is linear despite matrix being 2-dimensional. It is more efficiently.">mat</a> convention. For example for 3x3 matrix it will be: {x11, x21, x31, x12, x22, x32, x13, x23, x33} </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Matrix&lt;T&gt;&amp; Reference to *this matrix that was multiplied by matrix created from #l list. </dd></dl>

</div>
</div>
<a id="aa2555ef99ac404304432e38a38bf46f5" name="aa2555ef99ac404304432e38a38bf46f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2555ef99ac404304432e38a38bf46f5">&#9670;&#160;</a></span>operator+=() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_matrix.html">Matrix</a>&lt; T &gt; &amp; <a class="el" href="class_matrix.html">Matrix</a>&lt; T &gt;::operator+= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_matrix.html">Matrix</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds #other matrix to this one. Each value at according x and y position will be added to each other. If sizes of matrixes do not match no changes will be done. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>Added matrix. No changes will be done on this matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Matrix&lt;T&gt;&amp; Reference to *this matrix with values added. </dd></dl>

</div>
</div>
<a id="a66eeebd9fde92d999fa939f43ce250a7" name="a66eeebd9fde92d999fa939f43ce250a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66eeebd9fde92d999fa939f43ce250a7">&#9670;&#160;</a></span>operator+=() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_matrix.html">Matrix</a>&lt; T &gt; &amp; <a class="el" href="class_matrix.html">Matrix</a>&lt; T &gt;::operator+= </td>
          <td>(</td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds #value to each value in this matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>Value that will be added to each positions in this matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Matrix&lt;T&gt;&amp; Reference to *this matrix with values added. </dd></dl>

</div>
</div>
<a id="ac266a5c1c70819a79993bcf1976c460d" name="ac266a5c1c70819a79993bcf1976c460d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac266a5c1c70819a79993bcf1976c460d">&#9670;&#160;</a></span>operator+=() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_matrix.html">Matrix</a>&lt; T &gt; &amp; <a class="el" href="class_matrix.html">Matrix</a>&lt; T &gt;::operator+= </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; T &gt;&#160;</td>
          <td class="paramname"><em>l</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds #l list to this matrix. If sizes of matrixes do not match no changes will be done. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">l</td><td>initializer list that fits the convention of <a class="el" href="class_matrix.html#a68c40458ceb26414fd703acd3f98f2be" title="Array of matrix&#39;s values. It is linear despite matrix being 2-dimensional. It is more efficiently.">mat</a> convention. For example for 3x3 matrix it will be: {x11, x21, x31, x12, x22, x32, x13, x23, x33} </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Matrix&lt;T&gt;&amp; Reference to *this matrix with values added. </dd></dl>

</div>
</div>
<a id="a9eee11ca0c6f792e126688c0933fb850" name="a9eee11ca0c6f792e126688c0933fb850"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9eee11ca0c6f792e126688c0933fb850">&#9670;&#160;</a></span>operator-=() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_matrix.html">Matrix</a>&lt; T &gt; &amp; <a class="el" href="class_matrix.html">Matrix</a>&lt; T &gt;::operator-= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_matrix.html">Matrix</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Substracts #other matrix to this one. Each value at according x and y position will be substracted to each other. If sizes of matrixes do not match no changes will be done. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>Substracted matrix. No changes will be done on this matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Matrix&lt;T&gt;&amp; Reference to *this matrix with values substracted. </dd></dl>

</div>
</div>
<a id="a78c0d57c3e37e3bcba6ed3ec218cefda" name="a78c0d57c3e37e3bcba6ed3ec218cefda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78c0d57c3e37e3bcba6ed3ec218cefda">&#9670;&#160;</a></span>operator-=() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_matrix.html">Matrix</a>&lt; T &gt; &amp; <a class="el" href="class_matrix.html">Matrix</a>&lt; T &gt;::operator-= </td>
          <td>(</td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Substracts #value to each value in this matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>Value that will be substracted to each positions in this matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Matrix&lt;T&gt;&amp; Reference to *this matrix with values substracted. </dd></dl>

</div>
</div>
<a id="a580932af62fe857f9e4aa915e18adaab" name="a580932af62fe857f9e4aa915e18adaab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a580932af62fe857f9e4aa915e18adaab">&#9670;&#160;</a></span>operator-=() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_matrix.html">Matrix</a>&lt; T &gt; &amp; <a class="el" href="class_matrix.html">Matrix</a>&lt; T &gt;::operator-= </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; T &gt;&#160;</td>
          <td class="paramname"><em>l</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Substracts #l list to this matrix. If sizes of matrixes do not match no changes will be done. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">l</td><td>initializer list that fits the convention of <a class="el" href="class_matrix.html#a68c40458ceb26414fd703acd3f98f2be" title="Array of matrix&#39;s values. It is linear despite matrix being 2-dimensional. It is more efficiently.">mat</a> convention. For example for 3x3 matrix it will be: {x11, x21, x31, x12, x22, x32, x13, x23, x33} </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Matrix&lt;T&gt;&amp; Reference to *this matrix with values substracted. </dd></dl>

</div>
</div>
<a id="a85b13ebfb06ef4b9b1e5c832e2f1e6bb" name="a85b13ebfb06ef4b9b1e5c832e2f1e6bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85b13ebfb06ef4b9b1e5c832e2f1e6bb">&#9670;&#160;</a></span>operator/=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_matrix.html">Matrix</a>&lt; T &gt; &amp; <a class="el" href="class_matrix.html">Matrix</a>&lt; T &gt;::operator/= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_matrix.html">Matrix</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Divides this matrix by #other matrix. Each value at according x and y position will be divided to each other. If sizes of matrixes do not match no changes will be done. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td><a class="el" href="class_matrix.html" title="Represents the mathematical matrix and is able to preform matrix calculations.">Matrix</a> by which values this matrix will be divided. No changes will be done on this matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Matrix&lt;T&gt;&amp; Reference to *this matrix with values divided. </dd></dl>

</div>
</div>
<a id="a0e420a0361b60c45f32124526194670c" name="a0e420a0361b60c45f32124526194670c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e420a0361b60c45f32124526194670c">&#9670;&#160;</a></span>operator/=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_matrix.html">Matrix</a>&lt; T &gt; &amp; <a class="el" href="class_matrix.html">Matrix</a>&lt; T &gt;::operator/= </td>
          <td>(</td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Divides each value of this matrix by #value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>Value by which value at each position of this matrix will be divided. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Matrix&lt;T&gt;&amp; Reference to *this matrix with values divided. </dd></dl>

</div>
</div>
<a id="a998d8e9696ae022cf0aaaa30281fad12" name="a998d8e9696ae022cf0aaaa30281fad12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a998d8e9696ae022cf0aaaa30281fad12">&#9670;&#160;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_matrix.html">Matrix</a>&lt; T &gt; &amp; <a class="el" href="class_matrix.html">Matrix</a>&lt; T &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_matrix.html">Matrix</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Mimic #other matrix. Takes it's height, width and values and copies it to self. </p>
<p >No changes will be done on #other matrix. Data held until this point on this matrix will be lost. It rewrites this matrix to fit #other matrix size (Only if needed realloc will be done - if this matrix is bigger or equal to #other matrix size only <a class="el" href="class_matrix.html#a5ccb58af982a27187232cc8c07a94da8" title="Amount of Height in the matrix.">height</a> and <a class="el" href="class_matrix.html#ad43ea7e5e99130cffdb7b93ce25f4436" title="Amount of Width in the matrix.">width</a> values will change). Then using memcpy copies values stored in #other matrix.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td><a class="el" href="class_matrix.html" title="Represents the mathematical matrix and is able to preform matrix calculations.">Matrix</a> from which copy will be performed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Matrix&lt;T&gt;&amp; Reference to *this matrix with values and size exactly the same as #other matrix. </dd></dl>

</div>
</div>
<a id="a6325e23bef0bc407a92ddbccf1991ab8" name="a6325e23bef0bc407a92ddbccf1991ab8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6325e23bef0bc407a92ddbccf1991ab8">&#9670;&#160;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_matrix.html">Matrix</a>&lt; T &gt; &amp; <a class="el" href="class_matrix.html">Matrix</a>&lt; T &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; T &gt;&#160;</td>
          <td class="paramname"><em>l</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Mimic values stored in #l initializer list. </p>
<p >It takes values stored in #l list and copies it into this matrix array. If reallocation is needed it will be done (Only if the size of this matrix is too small). It allows us to set matrix's values at each position or one value for every position. For example for matrix mat of size 2x2 You can perform mat = {1, 3, 2, 4}; which will result in matrix with first row = [1, 2] and second row = [3, 4] Or You can perfoem mat = {1}; which will result in first row = [1, 1] and second row = [1, 1].</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">l</td><td>initializer list that fits the convention of <a class="el" href="class_matrix.html#a68c40458ceb26414fd703acd3f98f2be" title="Array of matrix&#39;s values. It is linear despite matrix being 2-dimensional. It is more efficiently.">mat</a> convention. For example for 3x3 matrix it will be: {x11, x21, x31, x12, x22, x32, x13, x23, x33} </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Matrix&lt;T&gt;&amp; Reference to *this matrix with values and size exactly the same as #l initializer list says. </dd></dl>

</div>
</div>
<a id="ad63e44d010ca1f300f6cc26cceb827a2" name="ad63e44d010ca1f300f6cc26cceb827a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad63e44d010ca1f300f6cc26cceb827a2">&#9670;&#160;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_matrix.html">Matrix</a>&lt; E &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_matrix.html">Matrix</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Method comparing two matrixes. It firstly checks the sizes. Then the types and at last values at each position. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>Value to which this one is compared. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true If everything is eaxctly the same in these matrixes. </dd>
<dd>
false If something is not the same in these matrixes. </dd></dl>

</div>
</div>
<a id="a18b7992498c06bea4e240bd7f504ee90" name="a18b7992498c06bea4e240bd7f504ee90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18b7992498c06bea4e240bd7f504ee90">&#9670;&#160;</a></span>operator[]()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class E &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">E * <a class="el" href="class_matrix.html">Matrix</a>&lt; E &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Getter for values in this matrix. It allows us to perform 2D array-style value getting or getter for pointer to each column. </p>
<p >For example for matrix mat of size 2x2 with first row = [1, 2] and second row = [3, 4] You will get: mat[0][0] = 1, mat[0][1] = 3, mat[1, 0] = 3, mat[1][1] = 4 And also: mat[0] will give You pointer to first column which is [1, 3].</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Index of an column </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>T* Pointer to the column. You can the recursivly perform another [] operator to get the 'y' value of this matrix. </dd></dl>

</div>
</div>
<a id="a5a70fa7bc4ca43742b4552189aa62296" name="a5a70fa7bc4ca43742b4552189aa62296"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a70fa7bc4ca43742b4552189aa62296">&#9670;&#160;</a></span>Width()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class E &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t <a class="el" href="class_matrix.html">Matrix</a>&lt; E &gt;::Width</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Getter for <a class="el" href="class_matrix.html#a5a70fa7bc4ca43742b4552189aa62296" title="Getter for Width field.">Width</a> field. </p>
<dl class="section return"><dt>Returns</dt><dd>Amount of Width in matrix </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a5ccb58af982a27187232cc8c07a94da8" name="a5ccb58af982a27187232cc8c07a94da8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ccb58af982a27187232cc8c07a94da8">&#9670;&#160;</a></span>height</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t <a class="el" href="class_matrix.html">Matrix</a>&lt; T &gt;::height {0}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Amount of Height in the matrix. </p>

</div>
</div>
<a id="a68c40458ceb26414fd703acd3f98f2be" name="a68c40458ceb26414fd703acd3f98f2be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68c40458ceb26414fd703acd3f98f2be">&#9670;&#160;</a></span>mat</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T* <a class="el" href="class_matrix.html">Matrix</a>&lt; T &gt;::mat {nullptr}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Array of matrix's values. It is linear despite matrix being 2-dimensional. It is more efficiently. </p>

</div>
</div>
<a id="a0b1de83dfa8d942e6ad25b4899f258de" name="a0b1de83dfa8d942e6ad25b4899f258de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b1de83dfa8d942e6ad25b4899f258de">&#9670;&#160;</a></span>MAX_MATRIX_SIZE</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr uint32_t <a class="el" href="class_matrix.html">Matrix</a>&lt; T &gt;::MAX_MATRIX_SIZE {4096}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Maximum size of a matrix that calculation will be performed on. This is a theoreticall value and if some calculation will be done on bigger matrix bad things happens. </p>

</div>
</div>
<a id="ac274897b49c87ddcca3398fce2555fb3" name="ac274897b49c87ddcca3398fce2555fb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac274897b49c87ddcca3398fce2555fb3">&#9670;&#160;</a></span>tmpMat</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T* <a class="el" href="class_matrix.html">Matrix</a>&lt; T &gt;::tmpMat {nullptr}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>second matrix allocated only once. This matrix is used for calculation purposes. It allows us to safely multiply matrixes without a need to allocate more memory. </p>

</div>
</div>
<a id="a34d60cf534436a6c0985c61eec302be2" name="a34d60cf534436a6c0985c61eec302be2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34d60cf534436a6c0985c61eec302be2">&#9670;&#160;</a></span>totalSize</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t <a class="el" href="class_matrix.html">Matrix</a>&lt; T &gt;::totalSize {0}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Total size is a multiplied values of a height and a width. It is a count f elements in an array of <a class="el" href="class_matrix.html#a68c40458ceb26414fd703acd3f98f2be" title="Array of matrix&#39;s values. It is linear despite matrix being 2-dimensional. It is more efficiently.">mat</a>. </p>

</div>
</div>
<a id="ad43ea7e5e99130cffdb7b93ce25f4436" name="ad43ea7e5e99130cffdb7b93ce25f4436"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad43ea7e5e99130cffdb7b93ce25f4436">&#9670;&#160;</a></span>width</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t <a class="el" href="class_matrix.html">Matrix</a>&lt; T &gt;::width {0}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Amount of Width in the matrix. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/Users/karolborecki/Desktop/CrustEngine/CrustEngine/Inc/Math/<a class="el" href="_matrix_8hpp_source.html">Matrix.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="class_matrix.html">Matrix</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.5 </li>
  </ul>
</div>
</body>
</html>
